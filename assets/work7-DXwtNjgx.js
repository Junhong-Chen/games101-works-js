var Tt=Object.defineProperty;var Bt=(o,t,e)=>t in o?Tt(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var ot=(o,t,e)=>(Bt(o,typeof t!="symbol"?t+"":t,e),e),gt=(o,t,e)=>{if(!t.has(o))throw TypeError("Cannot "+e)};var g=(o,t,e)=>(gt(o,t,"read from private field"),e?e.call(o):t.get(o)),B=(o,t,e)=>{if(t.has(o))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(o):t.set(o,e)},z=(o,t,e,s)=>(gt(o,t,"write to private field"),s?s.call(o,e):t.set(o,e),e);import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as Lt}from"./webgl-obj-loader.min-C5sT1AXD.js";import{G as Ct}from"./lil-gui.esm-DNkUmkFf.js";import{f as c,j as at,o as U,c as h,p as $,b as k,a as T,s as S,k as Rt,q as F,e as x,r as dt,n as G,i as St,m as ht,h as At,g as Z}from"./vec3-DxJeS3HW.js";import{c as Pt}from"./vec2-AJwhbUHB.js";class p{constructor(t,e){if(!t&&!e){const s=-Number.MAX_VALUE,n=Number.MAX_VALUE;this.pMax=c(s,s,s),this.pMin=c(n,n,n)}else!t&&e?(this.pMin=at(t),this.pMax=at(t)):(this.pMin=U(h(),t,e),this.pMax=$(h(),t,e))}diagonal(){return k(h(),this.pMax,this.pMin)}maxExtent(){const t=this.diagonal();return t[0]>t[1]&&t[0]>t[2]?0:t[1]>t[2]?1:2}surfaceArea(){const t=this.diagonal();return 2*(t[0]*t[1]+t[0]*t[2]+t[1]*t[2])}centroid(){const t=h();return T(t,this.pMin,this.pMax),S(t,t,.5),t}intersect(t){return new p(c(Math.max(this.pMin[0],t.pMin[0]),Math.max(this.pMin[1],t.pMin[1]),Math.max(this.pMin[2],t.pMin[2])),c(Math.min(this.pMax[0],t.pMax[0]),Math.min(this.pMax[1],t.pMax[1]),Math.min(this.pMax[2],t.pMax[2])))}offset(t){const e=h();return Rt(e,t,this.pMin),this.pMax[0]>this.pMin[0]&&(e[0]/=this.pMax[0]-this.pMin[0]),this.pMax[1]>this.pMin[1]&&(e[1]/=this.pMax[1]-this.pMin[1]),this.pMax[2]>this.pMin[2]&&(e[2]/=this.pMax[2]-this.pMin[2]),e}overlaps(t,e){const s=t.pMax[0]>=e.pMin[0]&&t.pMin[0]<=e.pMax[0],n=t.pMax[1]>=e.pMin[1]&&t.pMin[1]<=e.pMax[1],r=t.pMax[2]>=e.pMin[2]&&t.pMin[2]<=e.pMax[2];return s&&n&&r}inside(t,e){return t[0]>=e.pMin[0]&&t[0]<=e.pMax[0]&&t[1]>=e.pMin[1]&&t[1]<=e.pMax[1]&&t[2]>=e.pMin[2]&&t[2]<=e.pMax[2]}at(t){return t===0?this.pMin:this.pMax}intersectP(t,e,s){let n=-1/0,r=1/0;for(let i=0;i<3;i++){let a=(this.pMin[i]-t.origin[i])*e[i],l=(this.pMax[i]-t.origin[i])*e[i];s[i]||([a,l]=[l,a]),n=Math.max(n,a),r=Math.min(r,l)}return n<=r&&r>=0}static union(t,e){const s=new p;return e instanceof p?(U(s.pMin,t.pMin,e.pMin),$(s.pMax,t.pMax,e.pMax)):(U(s.pMin,t.pMin,e),$(s.pMax,t.pMax,e)),s}union(t){const e=new p;return t instanceof p?(U(e.pMin,this.pMin,t.pMin),$(e.pMax,this.pMax,t.pMax)):(U(e.pMin,this.pMin,t),$(e.pMax,this.pMax,t)),e}}class ct{constructor(t,e,s=0){this.origin=t,this.direction=e,this.directionInv=c(1/e[0],1/e[1],1/e[2]),this.t=s,this.tMin=0,this.tMax=Number.MAX_VALUE}at(t){const e=h();return F(e,this.origin,this.direction,t),e}toString(){return`[origin: ${this.origin}, direction: ${this.direction}, time: ${this.t}]`}}class H{constructor(){this.happened=!1,this.coords=h(),this.tcoords=h(),this.normal=h(),this.emit=h(),this.uv=Pt(),this.distance=Number.MAX_VALUE,this.obj=null,this.material=null}}class O{constructor(){if(this.constructor===O)throw new Error("Cannot instantiate abstract class")}intersect(t){throw new Error("Abstract method 'intersect' must be implemented")}intersectWithDetails(t,e,s){throw new Error("Abstract method 'intersectWithDetails' must be implemented")}getIntersection(t){throw new Error("Abstract method 'getIntersection' must be implemented")}getSurfaceProperties(t,e,s,n,r,i){throw new Error("Abstract method 'getSurfaceProperties' must be implemented")}evalDiffuseColor(t){throw new Error("Abstract method 'evalDiffuseColor' must be implemented")}getBounds(){throw new Error("Abstract method 'getBounds' must be implemented")}getArea(){throw new Error("Abstract method 'getArea' must be implemented")}Sample(t,e){throw new Error("Abstract method 'Sample' must be implemented")}hasEmit(){throw new Error("Abstract method 'hasEmit' must be implemented")}}class Ut{constructor(){this.bounds=new p,this.left=null,this.right=null,this.object=null,this.area=0,this.splitAxis=0,this.firstPrimOffset=0,this.nPrimitives=0}}const Y=class Y{constructor({primitives:t,maxPrimsInNode:e=1,splitMethod:s=Y.SplitMethod.NAIVE}){this.maxPrimsInNode=Math.min(255,e),this.splitMethod=s,this.primitives=t,t.length?this.root=this.recursiveBuild(t):this.root=null}worldBound(){return this.root?this.root.bounds:new p}recursiveBuild(t){const e=new Ut;let s=new p;for(let n of t)s=p.union(s,n.getBounds());if(t.length===1)return e.bounds=t[0].getBounds(),e.object=t[0],e.left=null,e.right=null,e.area=t[0].getArea(),e;if(t.length===2)return e.left=this.recursiveBuild([t[0]]),e.right=this.recursiveBuild([t[1]]),e.bounds=p.union(e.left.bounds,e.right.bounds),e.area=e.left.area+e.right.area,e;{let n=new p;for(let d of t)n=p.union(n,d.getBounds().centroid());const r=n.maxExtent();let i,a;switch(t.sort((d,u)=>d.getBounds().centroid()[r]-u.getBounds().centroid()[r]),this.splitMethod){case Y.SplitMethod.SAH:a=12;const d=n.surfaceArea();let u=1/0;for(let f=1;f<a;++f){const E=Math.floor(t.length*f/a),b=t.slice(0,E),I=t.slice(E);let A=new p;b.forEach(rt=>A=A.union(rt.getBounds().centroid()));let v=new p;I.forEach(rt=>v=v.union(rt.getBounds().centroid()));const W=A.surfaceArea(),Dt=v.surfaceArea(),Mt=(b.length*W+I.length*Dt)/d;Mt<u&&(i=f,u=Mt)}break;case Y.SplitMethod.NAIVE:i=1,a=2;break}const l=Math.floor(t.length*i/a),M=t.slice(0,l),m=t.slice(l);e.left=this.recursiveBuild(M),e.right=this.recursiveBuild(m),e.bounds=p.union(e.left.bounds,e.right.bounds),e.area=e.left.area+e.right.area}return e}intersect(t){return this.root?this.getIntersection(this.root,t):new H}getIntersection(t,e){const s=[e.direction[0]>0,e.direction[1]>0,e.direction[2]>0];if(!t.bounds.intersectP(e,e.directionInv,s))return new H;if(!t.left&&!t.right)return t.object.getIntersection(e);const n=this.getIntersection(t.left,e),r=this.getIntersection(t.right,e);return n.distance<r.distance?n:r}getSample(t,e,s,n){return!t.left||!t.right?(n=t.object.sample(s,n).pdf,n*=t.area):e<t.left.area?n=this.getSample(t.left,e,s,n):n=this.getSample(t.right,e-t.left.area,s,n),n}sample(t,e){const s=Math.sqrt(Math.random())*this.root.area;return e=this.getSample(this.root,s,t,e),e/=this.root.area,e}};ot(Y,"SplitMethod",{NAIVE:"NAIVE",SAH:"SAH"});let q=Y;const pt=.001;function $t(o){return o*Math.PI/180}function K(o,t=0,e=1){return Math.max(t,Math.min(e,o))}function Yt(o,t){return F(h(),o,t,-2*x(o,t))}class jt{constructor({position:t,intensity:e}){this.position=t,this.intensity=e}}var y,N,j;class Vt{constructor({width:t,height:e}){B(this,y,[]);B(this,N,[]);B(this,j,void 0);this.width=t,this.height=e,this.fov=40,this.backgroundColor=c(.235294,.67451,.843137),this.RussianRoulette=.8}get object(){return g(this,y)}get light(){return g(this,N)}add(t){t instanceof O?g(this,y).push(t):t instanceof jt&&g(this,N).push(t)}buildBVH({splitMethod:t}){z(this,j,new q({primitives:g(this,y),splitMethod:t}));for(const e of g(this,y))e instanceof O&&e.buildBVH({splitMethod:t})}intersect(t){return g(this,j)?g(this,j).intersect(t):new H}sampleLight(){let t=0;for(const s of g(this,y))s.hasEmit()&&(t+=s.getArea());let e=Math.random()*t;t=0;for(const s of g(this,y))if(s.hasEmit()&&(t+=s.getArea(),e<=t))return s.sample()}trace(t,e){let s=null;for(let n=0;n<e.length;++n){const i=e[n].intersect(t);i&&1/0<i.tNear&&(s=i)}return s}shade(t,e){let s=h();const{coords:n,normal:r,material:i}=t,{pos:a,pdf:l}=this.sampleLight(),{coords:M,normal:m,emit:d}=a,u=k(h(),M,n),f=dt(u);if(G(u,u),this.intersect(new ct(n,u)).distance>f-pt){const I=St(h(),u);S(s,ht(h(),d,i.eval(u,e,r)),x(u,r)*x(I,m)/Math.pow(f,2)/l)}let b=h();if(Math.random()<this.RussianRoulette){const I=G(h(),i.sample(e,r)),A=new ct(n,I),v=this.intersect(A),W=i.pdf(I,e,r);v.happened&&!v.material.hasEmission()&&W>pt&&S(b,ht(h(),this.shade(v,I),i.eval(I,e,r)),x(I,r)/W/this.RussianRoulette)}return T(h(),s,b)}castRay(t){const e=this.intersect(t);return e.happened?e.material.hasEmission()?e.material.emission:this.shade(e,t.direction):h()}}y=new WeakMap,N=new WeakMap,j=new WeakMap;function wt(o,t){let e,s;if(Math.abs(t[0])>Math.abs(t[1])){const r=1/Math.sqrt(t[0]*t[0]+t[2]*t[2]);s=c(t[2]*r,0,-t[0]*r)}else{const r=1/Math.sqrt(t[1]*t[1]+t[2]*t[2]);s=c(0,t[2]*r,-t[1]*r)}e=Z(h(),s,t);const n=h();return F(n,n,e,o[0]),F(n,n,s,o[1]),F(n,n,t,o[2]),n}var V;const P=class P{constructor({type:t=P.TYPE.DIFFUSE,emission:e=c(0,0,0),ior:s=1,kd:n=c(.8,.8,.8),ks:r=c(.2,.2,.2),specularExponent:i=25,roughness:a=0,metalness:l=0}){B(this,V,void 0);this.type=t,z(this,V,e),this.ior=s,this.kd=n,this.ks=r,this.specularExponent=i,this.roughness=a,this.metalness=l,this.a2=a*a}get emission(){return at(g(this,V))}getColorAt(t,e){return h()}hasEmission(){return dt(g(this,V))>Number.EPSILON}sample(t,e){let s;const n=Math.random(),r=Math.random(),i=2*Math.PI*r;switch(this.type){case P.TYPE.DIFFUSE:{const a=Math.abs(1-2*n),l=Math.sqrt(1-a*a),M=c(l*Math.cos(i),l*Math.sin(i),a);s=wt(M,e);break}case P.TYPE.MICROFACET:{const a=this.a2,l=Math.acos(Math.sqrt((1-n)/(n*(a-1)+1))),M=Math.sin(l);s=Yt(t,wt(c(M*Math.cos(i),M*Math.sin(i),Math.cos(l)),e));break}}return s}pdf(t,e,s){let n=0;switch(this.type){case P.TYPE.DIFFUSE:x(t,s)>0&&(n=.5/Math.PI);break;case P.TYPE.MICROFACET:const r=k(h(),t,e);G(r,r);const i=x(s,r),a=this.a2,l=(a-1)*i*i+1;n=a/(Math.PI*l*l)*i/(4*x(t,r));break}return n}eval(t,e,s){const n=h();switch(this.type){case P.TYPE.DIFFUSE:x(t,s)>0&&S(n,this.kd,1/Math.PI);break;case P.TYPE.MICROFACET:const i=x(t,s);if(i>0){let a=c(.04,.04,.04);const l=St(h(),e),M=t,m=T(h(),l,M);G(m,m);const d=Math.max(0,x(s,l)),u=i,f=this.distributionGGX(s,m),E=this.geometrySmith(d,u);At(a,a,this.kd,this.metalness);const b=this.fresnelSchlick(x(m,l),a),I=S(h(),b,f*E/(4*d*u)),A=S(h(),this.kd,(1-this.metalness)*(1/Math.PI));T(n,I,A)}break}return n}fresnelSchlick(t,e){const s=h(),n=k(h(),c(1,1,1),e);return F(s,e,n,Math.pow(K(1-t),5)),s}distributionGGX(t,e){const s=Math.pow(this.roughness,2),n=Math.max(0,x(t,e)),r=s;let i=Math.PI*Math.pow(n*n*(s-1)+1,2);return r/i}geometrySchlickGGX(t){if(t<=0)return 0;if(t>=1)return 1;const e=this.a2/2,s=t,n=t*(1-e)+e;return s/n}geometrySmith(t,e){const s=this.geometrySchlickGGX(t),n=this.geometrySchlickGGX(e);return s*n}};V=new WeakMap,ot(P,"TYPE",{DIFFUSE:"DIFFUSE",MICROFACET:"MICROFACET"});let w=P;function vt(o,t,e,s,n){const r=k(h(),t,o),i=k(h(),e,o),a=k(h(),s,o),l=Z(h(),n,i),M=Z(h(),a,r),m=S(h(),c(x(M,i),x(l,a),x(M,n)),1/x(l,r)),[d,u,f]=m;if(d>=0&&f>=0&&u>=0&&u+f<=1)return{tNear:d,u,v:f}}class Gt extends O{constructor(t,e,s,n=null){super(),this.v0=t,this.v1=e,this.v2=s,this.material=n;const r=k(h(),e,t),i=k(h(),s,t);this.normal=Z(h(),r,i),this.area=dt(this.normal)*.5,G(this.normal,this.normal)}intersect(t){return!0}intersectWithDistance(t,e,s){return!1}getIntersection(t){const e=new H;if(x(t.direction,this.normal)>0)return e;const s=vt(this.v0,this.v1,this.v2,t.origin,t.direction);if(s){const{tNear:n}=s;e.happened=!0,e.coords=t.at(n),e.normal=this.normal,e.distance=n,e.obj=this,e.material=this.material}return e}getSurfaceProperties(t,e,s,n,r,i){return{st:Pt(),normal:this.normal}}evalDiffuseColor(t){return c(.5,.5,.5)}getBounds(){return p.union(new p(this.v0,this.v1),this.v2)}sample(t,e){const s=Math.sqrt(Math.random()),n=Math.random(),r=1-s,i=s*(1-n),a=s*n;return F(t.coords,t.coords,this.v0,r),F(t.coords,t.coords,this.v1,i),F(t.coords,t.coords,this.v2,a),t.normal=this.normal,e=1/this.area,{pos:t,pdf:e}}getArea(){return this.area}hasEmit(){return this.material.hasEmission()}}var L,C;class R extends O{constructor({data:e,material:s=new w,scale:n=c(1,1,1),translate:r=h()}){super();B(this,L,[]);B(this,C,void 0);this.area=0,this.material=s;const i=c(1/0,1/0,1/0),a=c(-1/0,-1/0,-1/0),{indices:l,vertices:M}=e;for(let m=0;m<l.length;m+=3){const d=[];for(let f=0;f<3;f++){const E=c(M[l[m+f]*3+0],M[l[m+f]*3+1],M[l[m+f]*3+2]);ht(E,E,n),T(E,E,r),d[f]=E,U(i,i,E),$(a,a,E)}const u=new Gt(d[0],d[1],d[2],s);this.area+=u.area,g(this,L).push(u)}this.boundingBox=new p(i,a)}buildBVH({splitMethod:e}){z(this,C,new q({primitives:g(this,L).map(s=>s),splitMethod:e}))}intersect(e){let s=null;for(const[n,r]of g(this,L).entries()){const i=vt(r.v0,r.v1,r.v2,e.origin,e.direction);if(i){s={...i,index:n};break}}return s}getBounds(){return this.boundingBox}getSurfaceProperties({index:e,uv:s}){const n=g(this,L)[e],r=n.st[0],i=n.st[1],a=n.st[2];return st[0]=r[0]*(1-s[0]-s[1])+i[0]*s[0]+a[0]*s[1],st[1]=r[1]*(1-s[0]-s[1])+i[1]*s[0]+a[1]*s[1],{normal:n.normal,st}}evalDiffuseColor(e){const n=Math.floor(e[0]*5)%2^Math.floor(e[1]*5)%2,r=c(.815,.235,.031),i=c(.937,.937,.231);return At(h(),r,i,n)}getIntersection(e){return g(this,C)?g(this,C).intersect(e):new H}sample(e=new H,s){return e.emit=this.material.emission,s=g(this,C).sample(e,s),{pos:e,pdf:s}}getArea(){return this.area}hasEmit(){return this.material.hasEmission()}}L=new WeakMap,C=new WeakMap;class Ht{constructor(t){this.canvasEl=t}render(t,e=1){const{width:s,height:n,fov:r}=t,i=new Array(s*n),a=Math.tan($t(r*.5)),l=s/n,M=c(278,273,-800);let m=0;console.log(`SPP: ${e}`);for(let d=0;d<n;d++){for(let u=0;u<s;u++){const f=(2*(u+.5)/s-1)*l*a,E=-(2*(d+.5)/n-1)*a,b=c(-f,E,1);G(b,b);const I=new ct(M,b);i[m]=new h;for(let A=0;A<e;A++){const v=t.castRay(I);T(i[m],i[m],v)}S(i[m],i[m],1/e),m++}this.updateProgress((d+1)/t.height)}this.draw(t,i)}updateProgress(t){console.log(`%c${(t*100).toFixed(2)}%`,"color:dodgerblue")}draw(t,e){const s=this.canvasEl.getContext("2d"),n=e.length,r=s.createImageData(t.width,t.height);for(var i=0;i<n;i++){var a=i*4;r.data[a]=Math.pow(K(e[i][0]),.6)*255,r.data[a+1]=Math.pow(K(e[i][1]),.6)*255,r.data[a+2]=Math.pow(K(e[i][2]),.6)*255,r.data[a+3]=255}s.putImageData(r,0,0)}}function X(o){return new Promise((t,e)=>{fetch(o).then(s=>s.text()).then(s=>{const n=new Lt.OBJ.Mesh(s);t(n)}).catch(s=>{e(s)})})}const yt=document.querySelector.bind(document),nt=yt("#canvas-el"),lt=yt("#img-el"),Ot=parseInt(nt.getAttribute("width")),Xt=parseInt(nt.getAttribute("height")),D=new Vt({width:Ot,height:Xt}),qt=new Ht(nt),kt=new w({type:w.TYPE.DIFFUSE,kd:c(.63,.065,.05),roughness:.7,metalness:.3}),Ft=new w({type:w.TYPE.DIFFUSE,kd:c(.14,.45,.091),roughness:.5,metalness:.5}),J=new w({type:w.TYPE.DIFFUSE,kd:c(.725,.71,.68),roughness:.7,metalness:.3}),ut=new w({type:w.TYPE.DIFFUSE,kd:c(1,.77,.33),roughness:.2,metalness:.8}),mt=new w({type:w.TYPE.DIFFUSE,kd:c(.95,.95,.95),roughness:.01,metalness:1}),Nt=c(.747+.058,.747+.258,.747),Wt=c(.74+.287,.74+.16,.74),zt=c(.737+.642,.737+.159,.737),_=h();T(_,S(h(),Nt,8),S(h(),Wt,15.6));T(_,_,S(h(),zt,18.4));const Kt=new w({type:w.TYPE.DIFFUSE,emission:_,kd:c(.65,.65,.65)}),Jt=X("/games101-works-js/models/cornellbox/floor.obj"),Qt=X("/games101-works-js/models/cornellbox/shortbox.obj"),Zt=X("/games101-works-js/models/cornellbox/tallbox.obj"),_t=X("/games101-works-js/models/cornellbox/left.obj"),te=X("/games101-works-js/models/cornellbox/right.obj"),ee=X("/games101-works-js/models/cornellbox/light.obj");let xt,tt,et,Et,It,bt;Promise.all([Jt,Qt,Zt,_t,te,ee]).then(o=>{xt=new R({data:o[0],material:J}),tt=new R({data:o[1],material:ut}),et=new R({data:o[2],material:mt}),Et=new R({data:o[3],material:kt}),It=new R({data:o[4],material:Ft}),bt=new R({data:o[5],material:Kt}),D.add(xt),D.add(tt),D.add(et),D.add(Et),D.add(It),D.add(bt),D.buildBVH({splitMethod:q.SplitMethod.SAH})});const ft=new Ct,it={render:se,material:w.TYPE.DIFFUSE,spp:1};let Q;function se(o=it.spp){if(!Q._disabled){Q.disable(),lt.style.display="none",nt.style.display="block";const t=new Date;setTimeout(()=>{qt.render(D,o);const s=(new Date-t)/1e3,n=Math.floor(s/3600),r=Math.floor(s%3600/60),i=s%60;console.log(`Render complete: 
Time Taken: ${n} hrs, ${r} mins, ${i} secs
`),setTimeout(()=>{Q.enable()},null)},null)}}Q=ft.add(it,"render");ft.add(it,"spp",1,1024,1);ft.add(it,"material",w.TYPE).onFinishChange(o=>{kt.type=o,Ft.type=o,J.type=o,ut.type=o,mt.type=o,o===w.TYPE.DIFFUSE?(tt.material=J,et.material=J):(tt.material=ut,et.material=mt),lt.style.display!=="none"&&(lt.src=`/games101-works-js/images/cornellbox-${o.toLowerCase()}.png`)});
