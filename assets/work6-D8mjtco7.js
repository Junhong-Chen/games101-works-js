var pt=Object.defineProperty;var mt=(r,t,n)=>t in r?pt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n;var it=(r,t,n)=>(mt(r,typeof t!="symbol"?t+"":t,n),n),ot=(r,t,n)=>{if(!t.has(r))throw TypeError("Cannot "+n)};var p=(r,t,n)=>(ot(r,t,"read from private field"),n?n.call(r):t.get(r)),R=(r,t,n)=>{if(t.has(r))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(r):t.set(r,n)},P=(r,t,n,e)=>(ot(r,t,"write to private field"),e?e.call(r,n):t.set(r,n),n);import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as xt}from"./webgl-obj-loader.min-C5sT1AXD.js";import{G as wt}from"./lil-gui.esm-DNkUmkFf.js";import{f,j as q,b as C,c as a,a as k,s as N,k as St,o as b,p as G,q as Bt,e as S,n as _,i as lt,m as Et,h as It,g as j}from"./vec3-DxJeS3HW.js";import{f as At}from"./vec2-AJwhbUHB.js";class nt{constructor({position:t,intensity:n}){this.position=t,this.intensity=n}}class g{constructor(t,n){if(!t&&!n){const e=-Number.MAX_VALUE,i=Number.MAX_VALUE;this.pMax=f(e,e,e),this.pMin=f(i,i,i)}else!t&&n?(this.pMin=q(t),this.pMax=q(t)):(this.pMin=f(Math.min(t[0],n[0]),Math.min(t[1],n[1]),Math.min(t[2],n[2])),this.pMax=f(Math.max(t[0],n[0]),Math.max(t[1],n[1]),Math.max(t[2],n[2])))}diagonal(){return C(a(),this.pMax,this.pMin)}maxExtent(){const t=this.diagonal();return t[0]>t[1]&&t[0]>t[2]?0:t[1]>t[2]?1:2}surfaceArea(){const t=this.diagonal();return 2*(t[0]*t[1]+t[0]*t[2]+t[1]*t[2])}centroid(){const t=a();return k(t,this.pMin,this.pMax),N(t,t,.5),t}intersect(t){return new g(f(Math.max(this.pMin[0],t.pMin[0]),Math.max(this.pMin[1],t.pMin[1]),Math.max(this.pMin[2],t.pMin[2])),f(Math.min(this.pMax[0],t.pMax[0]),Math.min(this.pMax[1],t.pMax[1]),Math.min(this.pMax[2],t.pMax[2])))}offset(t){const n=a();return St(n,t,this.pMin),this.pMax[0]>this.pMin[0]&&(n[0]/=this.pMax[0]-this.pMin[0]),this.pMax[1]>this.pMin[1]&&(n[1]/=this.pMax[1]-this.pMin[1]),this.pMax[2]>this.pMin[2]&&(n[2]/=this.pMax[2]-this.pMin[2]),n}overlaps(t,n){const e=t.pMax[0]>=n.pMin[0]&&t.pMin[0]<=n.pMax[0],i=t.pMax[1]>=n.pMin[1]&&t.pMin[1]<=n.pMax[1],s=t.pMax[2]>=n.pMin[2]&&t.pMin[2]<=n.pMax[2];return e&&i&&s}inside(t,n){return t[0]>=n.pMin[0]&&t[0]<=n.pMax[0]&&t[1]>=n.pMin[1]&&t[1]<=n.pMax[1]&&t[2]>=n.pMin[2]&&t[2]<=n.pMax[2]}intersectP(t,n,e){let i=-1/0,s=1/0;for(let o=0;o<3;o++){let c=(this.pMin[o]-t.origin[o])*n[o],h=(this.pMax[o]-t.origin[o])*n[o];e[o]||([c,h]=[h,c]),i=Math.max(i,c),s=Math.min(s,h)}return i<s&&s>=0}static union(t,n){const e=new g;return n instanceof g?(b(e.pMin,t.pMin,n.pMin),G(e.pMax,t.pMax,n.pMax)):(b(e.pMin,t.pMin,n),G(e.pMax,t.pMax,n)),e}union(t){const n=new g;return t instanceof g?(b(n.pMin,this.pMin,t.pMin),G(n.pMax,this.pMax,t.pMax)):(b(n.pMin,this.pMin,t),G(n.pMax,this.pMax,t)),n}}class tt{constructor(){this.happened=!1,this.coords=a(),this.normal=a(),this.distance=Number.MAX_VALUE,this.obj=null,this.m=null}}class rt{constructor(){this.bounds=new g,this.left=null,this.right=null,this.object=null}}const H=class H{constructor({primitives:t,maxPrimsInNode:n=1,splitMethod:e=H.SplitMethod.NAIVE}){if(this.maxPrimsInNode=Math.min(255,n),this.splitMethod=e,this.primitives=t,t.length===0){this.root=null;return}const i=new Date;this.root=this.recursiveBuild(t);const o=(new Date-i)/1e3,c=Math.floor(o/3600),h=Math.floor(o%3600/60),M=o%60;console.log(`BVH Generation complete: 
Time Taken: ${c} hrs, ${h} mins, ${M} secs
`)}recursiveBuild(t){const n=new rt;let e=new g;for(let i of t)e=e.union(i.getBounds());if(t.length===1)return n.bounds=t[0].getBounds(),n.object=t[0],n;if(t.length===2)return n.left=this.recursiveBuild([t[0]]),n.right=this.recursiveBuild([t[1]]),n.bounds=n.left.bounds.union(n.right.bounds),n;{let i=new g;for(let u of t)i=i.union(u.getBounds().centroid());const s=i.maxExtent();let o,c;switch(t.sort((u,d)=>u.getBounds().centroid()[s]-d.getBounds().centroid()[s]),this.splitMethod){case H.SplitMethod.SAH:c=12;const u=i.surfaceArea();let d=1/0;for(let m=1;m<c;++m){const x=Math.floor(t.length*m/c),E=t.slice(0,x),I=t.slice(x);let w=new g;E.forEach(V=>w=w.union(V.getBounds().centroid()));let v=new g;I.forEach(V=>v=v.union(V.getBounds().centroid()));const A=w.surfaceArea(),D=v.surfaceArea(),L=(E.length*A+I.length*D)/u;L<d&&(o=m,d=L)}break;case H.SplitMethod.NAIVE:o=1,c=2;break}const h=Math.floor(t.length*o/c),M=t.slice(0,h),l=t.slice(h);n.left=this.recursiveBuild(M),n.right=this.recursiveBuild(l),n.bounds=n.left.bounds.union(n.right.bounds)}return n}recursiveBuildForSAH(t){const n=new rt;let e=new g;if(t.forEach(i=>e=e.union(e,i.getBounds())),t.length===1)return n.bounds=t[0].getBounds(),n.object=t[0],n.left=null,n.right=null,n;if(t.length===2)return n.left=this.recursiveBuildForSAH([t[0]]),n.right=this.recursiveBuildForSAH([t[1]]),n.bounds=n.left.bounds.union(n.right.bounds),n;{let i=new g;t.forEach(l=>i=i.union(l.getBounds().centroid()));const s=i.maxExtent();let o=1/0,c=0;t.sort((l,u)=>l.getBounds().centroid()[s]-u.getBounds().centroid()[s]);for(let l=1;l<B;++l){const u=Math.floor(t.length*l/B),d=t.slice(0,u),m=t.slice(u);let x=new g;d.forEach(A=>x=x.union(x,A.getBounds()));let E=new g;m.forEach(A=>E=x.union(E,A.getBounds()));const I=x.surfaceArea(),w=E.surfaceArea(),v=(d.length*I+m.length*w)/e.surfaceArea();v<o&&(o=v,c=u)}const h=t.slice(0,c),M=t.slice(c);n.left=this.recursiveBuildForSAH(h),n.right=this.recursiveBuildForSAH(M),n.bounds=n.left.bounds.union(n.right.bounds)}return n}intersect(t){return this.root?this.getIntersection(this.root,t):new tt}getIntersection(t,n){const e=[n.direction[0]>0,n.direction[1]>0,n.direction[2]>0];if(!t.bounds.intersectP(n,n.directionInv,e))return new tt;if(!t.left&&!t.right)return t.object.getIntersection(n);const i=this.getIntersection(t.left,n),s=this.getIntersection(t.right,n);return i.distance<s.distance?i:s}};it(H,"SplitMethod",{NAIVE:"NAIVE",SAH:"SAH"});let O=H;class U{constructor(t,n,e=0){this.origin=t,this.direction=n,this.directionInv=f(1/n[0],1/n[1],1/n[2]),this.t=e,this.tMin=0,this.tMax=Number.MAX_VALUE}at(t){const n=a();return Bt(n,this.origin,this.direction,t),n}toString(){return`[origin: ${this.origin}, direction: ${this.direction}, time: ${this.t}]`}}const Q={DIFFUSE_AND_GLOSSY:0,REFLECTION_AND_REFRACTION:1,REFLECTION:2};var X,Y,z;class vt{constructor({type:t=Q.DIFFUSE_AND_GLOSSY,color:n=f(1,1,1),emission:e=f(0,0,0)}){R(this,X,void 0);R(this,Y,void 0);R(this,z,void 0);P(this,X,t),P(this,Y,n),P(this,z,e),this.ior=1,this.kd=.8,this.ks=.2,this.specularExponent=25}get type(){return p(this,X)}get color(){return p(this,Y)}get emission(){return p(this,z)}getColorAt(t,n){return a()}}X=new WeakMap,Y=new WeakMap,z=new WeakMap;class W{constructor(){}intersect(){}getIntersection(){}getSurfaceProperties(){}getBounds(){}evalDiffuseColor(){}}function ct(r){return f(r,r,r)}function ut(r,t,n){return Math.max(r,Math.min(t,n))}function Nt(r,t,n){let e=ut(-1,1,S(r,t)),i=1,s=n,o=q(t);e<0?e=-e:([i,s]=[s,i],lt(o,t));const c=i/s,h=1-c*c*(1-e*e);return h<0?a():k(a(),N(a(),r,c),N(a(),o,c*e-Math.sqrt(h)))}function at(r,t,n){let e=ut(-1,1,S(r,t)),i=1,s=n;e>0&&([i,s]=[s,i]);const o=i/s*Math.sqrt(Math.max(0,1-e*e));if(o>=1)return 1;{const c=Math.sqrt(Math.max(0,1-o*o));e=Math.abs(e);const h=(s*e-i*c)/(s*e+i*c),M=(i*e-s*c)/(i*e+s*c);return(h*h+M*M)/2}}function ht(r,t){return C(a(),r,N(a(),t,2*S(r,t)))}var T,J,Z,$;class Dt{constructor({width:t=1280,height:n=720,fov:e=90,backgroundColor:i=f(.235294,.67451,.843137)}){R(this,T,[]);R(this,J,[]);R(this,Z,5);R(this,$,void 0);this.width=t,this.height=n,this.fov=e,this.backgroundColor=i}add(t){t instanceof W?p(this,T).push(t):t instanceof nt&&p(this,J).push(t)}buildBVH({splitMethod:t}){console.log(" - Generating BVH..."),P(this,$,new O({primitives:p(this,T),splitMethod:t}));for(const n of p(this,T))n instanceof W&&n.buildBVH({splitMethod:t})}intersect(t){return p(this,$).intersect(t)}castRay(t,n){if(n>p(this,Z))return a();const e=this.intersect(t),{happened:i,material:s,obj:o,coords:c,uv:h}=e,M=0;let l=q(this.backgroundColor);if(i){const u=q(c),{normal:d,st:m}=o.getSurfaceProperties({index:M,uv:h,hitPoint:u}),x=k(a(),u,N(a(),d,Number.EPSILON)),E=C(a(),u,N(a(),d,Number.EPSILON));switch(s.type){case Q.REFLECTION_AND_REFRACTION:{const I=_(a(),ht(t.direction,d)),w=_(a(),Nt(t.direction,d,s.ior)),v=S(I,d)<0?E:x,A=S(w,d)<0?E:x,D=this.castRay(new U(v,I),n+1),L=this.castRay(new U(A,w),n+1),V=at(t.dir,d,s.ior);l=k(a(),N(a(),D,V),N(a(),L,1-V));break}case Q.REFLECTION:{const I=at(t.direction,d,s.ior),w=this.reflect(t.direction,d),v=S(w,d)<0?x:E,A=this.castRay(new U(v,w),n+1);l=N(a(),A,I);break}case Q.DIFFUSE_AND_GLOSSY:default:{let I=a(),w=a();const v=S(t.direction,d)<0?x:E;for(const A of p(this,J)){const D=C(a(),A.position,u);S(D,D),_(D,D);const L=Math.max(0,S(D,d));p(this,$).intersect(new U(v,D)).happened||k(I,I,ct(A.intensity*L));const gt=ht(lt(a(),D),d);k(w,w,ct(Math.pow(Math.max(0,-S(gt,t.direction)),s.specularExponent)*A.intensity))}l=k(a(),N(a(),Et(a(),I,o.evalDiffuseColor(m)),s.kd),N(a(),w,s.ks));break}}}return l}}T=new WeakMap,J=new WeakMap,Z=new WeakMap,$=new WeakMap;function dt(r,t,n,e,i){const s=C(a(),t,r),o=C(a(),n,r),c=C(a(),e,r),h=j(a(),i,o),M=j(a(),c,s),l=N(a(),f(S(M,o),S(h,c),S(M,i)),1/S(h,s)),[u,d,m]=l;if(u>=0&&m>=0&&d>=0&&d+m<=1)return{tNear:u,u:d,v:m}}class Rt extends W{constructor(t,n,e,i){super(),this.v0=t,this.v1=n,this.v2=e,this.material=i;const s=C(a(),n,t),o=C(a(),e,t);this.normal=_(a(),j(a(),s,o))}getSurfaceProperties(){return{normal:this.normal}}getBounds(){return g.union(new g(this.v0,this.v1),this.v2)}getIntersection(t){const n=new tt;if(S(t.direction,this.normal)>0)return n;const e=dt(this.v0,this.v1,this.v2,t.origin,t.direction);if(!e)return n;const{tNear:i,u:s,v:o}=e;return n.happened=!0,n.coords=f(i,s,o),n.normal=this.normal,n.distance=i,n.obj=this,n.material=this.material,n.uv=At(s,o),n}evalDiffuseColor(){return f(.5,.5,.5)}}var F,K;class Ct extends W{constructor(n){super();R(this,F,[]);R(this,K,void 0);const e=f(1/0,1/0,1/0),i=f(-1/0,-1/0,-1/0),{indices:s,vertices:o}=n;for(let c=0;c<s.length;c+=3){const h=[];for(let l=0;l<3;l++){const u=f(o[s[c+l]*3+0]*60,o[s[c+l]*3+1]*60,o[s[c+l]*3+2]*60);h[l]=u,b(e,e,u),G(i,i,u)}const M=new vt("DIFFUSE_AND_GLOSSY",f(.5,.5,.5),f(0,0,0));M.kd=.6,M.ks=0,M.specularExponent=0,p(this,F).push(new Rt(h[0],h[1],h[2],M))}this.boundingBox=new g(e,i)}buildBVH({splitMethod:n}){console.log(" - Generating BVH..."),P(this,K,new O({primitives:p(this,F).map(e=>e),splitMethod:n}))}intersect(n){let e=null;for(const[i,s]of p(this,F).entries()){const o=dt(s.v0,s.v1,s.v2,n.origin,n.direction);if(o){e={...o,index:i};break}}return e}getBounds(){return this.boundingBox}getSurfaceProperties({index:n,uv:e}){const i=p(this,F)[n],s=i.st[0],o=i.st[1],c=i.st[2];return st[0]=s[0]*(1-e[0]-e[1])+o[0]*e[0]+c[0]*e[1],st[1]=s[1]*(1-e[0]-e[1])+o[1]*e[0]+c[1]*e[1],{normal:i.normal,st}}evalDiffuseColor(n){const i=Math.floor(n[0]*5)%2^Math.floor(n[1]*5)%2,s=f(.815,.235,.031),o=f(.937,.937,.231);return It(a(),s,o,i)}getIntersection(n){return p(this,K).intersect(n)}}F=new WeakMap,K=new WeakMap;function Vt(r){return r*Math.PI/180}class kt{constructor(t){this.canvasEl=t}render(t){const{width:n,height:e,fov:i}=t,s=new Array(n*e),o=Math.tan(Vt(i*.5)),c=t.width/t.height,h=f(-1,5,10);let M=0;for(let l=0;l<e;l++){for(let u=0;u<n;u++){const d=(2*(u+.5)/n-1)*c*o,m=-(2*(l+.5)/e-1)*o,x=_(a(),f(d,m,-1)),E=new U(h,x);s[M++]=t.castRay(E,0)}this.updateProgress((l+1)/e)}this.draw(t,s)}draw(t,n){const e=this.canvasEl.getContext("2d"),i=n.length,s=e.createImageData(t.width,t.height);for(var o=0;o<i;o++){var c=o*4;s.data[c]=n[o][0]*255,s.data[c+1]=n[o][1]*255,s.data[c+2]=n[o][2]*255,s.data[c+3]=255}e.putImageData(s,0,0)}clear(t){this.canvasEl.getContext("2d").clearRect(0,0,t.width,t.height)}updateProgress(t){const n=Math.max(0,Math.min(100,t*100));console.info(`%c${n.toFixed(1)}%`,"color:dodgerblue")}}function Ft(r){return new Promise((t,n)=>{fetch(r).then(e=>e.text()).then(e=>{const i=new xt.OBJ.Mesh(e);t(i)}).catch(e=>{n(e)})})}const et=document.querySelector("#canvas-el"),Ot=parseInt(et.getAttribute("width")),yt=parseInt(et.getAttribute("height")),y=new Dt({width:Ot,height:yt}),ft=new kt(et),Lt=new wt,Pt={splitMethod:O.SplitMethod.NAIVE};y.add(new nt({position:f(-20,70,20),intensity:1}));y.add(new nt({position:f(20,70,20),intensity:1}));Ft("/models/bunny/bunny.obj").then(r=>{const t=new Ct(r);y.add(t),y.buildBVH({splitMethod:O.SplitMethod.NAIVE}),Mt()});function Mt(){const r=new Date;ft.render(y);const n=(new Date-r)/1e3,e=Math.floor(n/3600),i=Math.floor(n%3600/60),s=n%60;console.log(`Render complete: 
Time Taken: ${e} hrs, ${i} mins, ${s} secs
`)}Lt.add(Pt,"splitMethod",O.SplitMethod).onChange(r=>{ft.clear(y),y.buildBVH({splitMethod:r}),setTimeout(()=>Mt(),null)});
