<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>作业-4</title>
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://docs.opencv.org/4.9.0/opencv.js"></script>
</head>

<body>
  <article>
    <h4>总览</h4>
    <p>Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中，你需要实现 de Casteljau 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时，你可以支持绘制由更多点来控制的 Bézier
      曲线)。</p>
    <h4>代码框架</h4>
    <p>你需要修改的函数在提供的 <strong>main.cpp</strong> 文件中：</p>
    <ul>
      <li>
        <strong>bezier：</strong>该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个 OpenCV::Mat 对象作为输入，没有返回值。它会使 t 在 0 到 1
        的范围内进行迭代，并在每次迭代中使 t 增加一个微小值。对于每个需要计算的 t，将调用另一个函数 recursive_bezier，然后该函数将返回在 Bézier 曲线上 t 处的点。最后，将返回的点绘制在
        OpenCV::Mat 对象上。
      </li>
      <li>
        <strong>recursive_bezier：</strong>该函数使用一个控制点序列和一个浮点数 t 作为输入，实现 <strong>de Casteljau</strong> 算法来返回 Bézier
        曲线上对应点的坐标。
      </li>
    </ul>
    <p>
      <strong>de Casteljau</strong> 算法说明如下：
    <ol>
      <li>
        考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。
      </li>
      <li>
        用 t : (1 − t) 的比例细分每个线段，并找到该分割点。
      </li>
      <li>
        得到的分割点作为新的控制点序列，新序列的长度会减少一。
      </li>
      <li>
        如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。
      </li>
    </ol>
    </p>
    <p>使用 [0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。</p>
    <h4>注意事项</h4>
    <p>在确保代码框架一切正常后，就可以开始完成你自己的实现了。注释掉 main 函数中 while 循环内调用 naive_bezier 函数的行，并取消对 bezier 函数的注释。要求你的实现将 Bézier
      曲线绘制为<strong>绿色</strong>。</p>
    <p>如果要确保实现正确，请同时调用 naive_bezier 和 bezier 函数，如果实现正确，则两者均应写入大致相同的像素，因此该曲线将表现为<strong>黄色</strong>。如果是这样，你可以确保实现正确。</p>
    <h4>拓展</h4>
    <p>实现对 Bézier 曲线的反走样。(对于一个曲线上的点，不只把它对应于一个像素，你需要根据到像素中心的距离来考虑与它相邻的像素的颜色。)</p>
  </article>
  <canvas id="canvas-el" width="700" height="700"></canvas>
  <script src="./index.js" type="module"></script>
</body>

</html>